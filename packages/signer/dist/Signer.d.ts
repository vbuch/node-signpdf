/**
 * Abstract Signer class taking care of creating a suitable signature for a given pdf.
 * Subclasses should specify the required signature and hashing algorithms (either through
 * the `signAlgorithm` and `hashAlgorithm` attributes, or by overriding the `getSignAlgorithm`
 * and `getHashAlgorithm` methods), as well as provide the signing certificate and private key
 * used for signing (by implementing the `getCertificate` and `getKey` methods).
 */
export class Signer extends ISigner {
    /** Signature algorithm used for PDF signing
     * @type {string}
     */
    signAlgorithm: string;
    /** Hash algorithm used for PDF signing
     * @type {string}
     */
    hashAlgorithm: string;
    /**
     * Method to retrieve the signature algorithm used for PDF signing.
     * To be implemented by subclasses or set in the `signAlgorithm` attribute.
     * @returns {Promise<string>}
     */
    getSignAlgorithm(): Promise<string>;
    /**
     * Method to retrieve the hashing algorithm used for PDF signing.
     * To be implemented by subclasses or set in the `hashAlgorithm` attribute.
     * @returns {Promise<string>}
     */
    getHashAlgorithm(): Promise<string>;
    /**
     * Method to retrieve the signing certificate. If multiple certificates are returned, the first
     * one is used for the actual signing, while the others are added for verification purposes.
     * To be implemented by subclasses.
     * @returns {Promise<Uint8Array | Uint8Array[]>}
     */
    getCertificate(): Promise<Uint8Array | Uint8Array[]>;
    /**
     * Method to retrieve the private key used for signing.
     * The returned private key should be in its PKCS#8 binary representation.
     * To be implemented by subclasses.
     * @returns {Promise<Uint8Array>}
     */
    getKey(): Promise<Uint8Array>;
    /**
     * Get a "crypto" extension.
     * @returns {pkijs.ICryptoEngine}
     */
    getCrypto(): pkijs.ICryptoEngine;
    /**
     * Obtain the certificates used for signing (first one) and verification (whole list).
     * @returns {pkijs.Certificate[]}
     */
    obtainCertificates(): pkijs.Certificate[];
    /**
     * Obtain the private key used for signing.
     * @returns {CryptoKey}
     */
    obtainKey(): CryptoKey;
    /**
     * Obtain the signed attributes, which are the actual content that is signed in detached mode.
     * @returns {pkijs.Attribute[]}
     */
    obtainSignedAttributes(signingTime: any, data: any, signCert: any): pkijs.Attribute[];
    /**
     * Obtain the unsigned attributes.
     * @returns {pkijs.Attribute[]}
     */
    obtainUnsignedAttributes(signature: any): pkijs.Attribute[];
    crypto: pkijs.ICryptoEngine;
    /**
     * Verify whether the signature generated by the sign function is correct.
     * @param {Buffer} cmsSignedBuffer
     * @param {Buffer} pdfBuffer
     * @returns {boolean}
     */
    verify(cmsSignedBuffer: Buffer, pdfBuffer: Buffer): boolean;
}
import { ISigner } from '@signpdf/utils';
import * as pkijs from 'pkijs';
//# sourceMappingURL=Signer.d.ts.map